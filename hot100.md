# Hot100
## 2021.1.22 第一周
## [48. 旋转图像](https://leetcode-cn.com/problems/rotate-image/solution/li-kou-48xiao-bai-du-neng-kan-dong-de-fang-fa-zhu-/)[Liu]
这题是一道矩阵旋转类型的题目，本质上是两数交换的高级版.并且矩阵问题有很深的应用，是很好的题。
下图以最外围为例，不同颜色的区块代表了需要置换的区域：

![show1](./pic/48/show1.png)

我们来寻找其中的规律，以四个角为例子，我们发现可以采用两个变量来表示四个角。顺时针方向分别是(pos1,pos1),(pos1,pos2),(pos2,po2),(pos2,pos1)。我们只要交换这四个角就可以完成这四个数的交换，之后我们需要一次遍历傍边的数，我们引入一个add来完成这个操作。由于pos1+add< pos2，我们找到了循环结束条件。

![show2](./pic/48/show2.png)

外圈循环结束之后，我们进入里圈。我们将pos1+1,pos2-1自然就进入了里圈。循环结束条件是pos1< pos2。
```python
def rotate(matrix):
    pos1,pos2=0,len(matrix)-1
    while pos1<pos2:
        add=0
        while add<pos2-pos1:
            temp=matrix[pos1+add][pos2]
            matrix[pos1+add][pos2]=matrix[pos1][pos1+add]
            matrix[pos1][pos1+add]=matrix[pos2-add][pos1]
            matrix[pos2-add][pos1]=matrix[pos2][pos2-add]
            matrix[pos2][pos2-add]=temp
            add+=1
        pos1+=1
        pos2-=1
# matrix=[[1,2,3],[4,5,6],[7,8,9]] demo1
matrix=[[ 5, 1, 9,11],[ 2, 4, 8,10],[13, 3, 6, 7],[15,14,12,16]]#demo2
print(rotate(matrix))
```

当然由于python的特性，我们也可以不要temp:
```python
def rotate(matrix):
    pos1=0
    pos2=len(matrix)-1
    while pos1<pos2:
        add=0
        while pos1+add<pos2:
            matrix[pos1+add][pos2],matrix[pos2][pos2-add],matrix[pos2-add][pos1],matrix[pos1][pos1+add]=matrix[pos1][pos1+add],matrix[pos1+add][pos2],matrix[pos2][pos2-add],matrix[pos2-add][pos1]
            add+=1
        pos1+=1
        pos2-=1
matrix=[[ 5, 1, 9,11],[ 2, 4, 8,10],[13, 3, 6, 7],[15,14,12,16]]
print(rotate(matrix))
```
但不建议这么写，一是可读性太差了，二是不利于调试。

## [75. 颜色分类](https://leetcode-cn.com/problems/sort-colors/)[Li]

```python
#75. 颜色分类
#[题解](https://leetcode-cn.com/problems/sort-colors/solution/kuai-su-pai-xu-partition-guo-cheng-she-ji-xun-huan/)
def sortColors(nums):
    p0=cur=0 #p0用来交换0，cur遍历指针事实上就是指向1
    p2=len(nums)-1#p2用来交换2
    while cur<p2:
        if nums[cur]==0:
            nums[cur],nums[p0]=nums[p0],nums[cur]
            cur+=1
            p0+=1
        elif nums[cur]==1:
            cur+=1
        else:
            nums[cur],nums[p2]=nums[p2],nums[cur]
            p2-=1
    return nums
print(sortColors([2,0,2,1,1,0]))
```
## 2021.1.23
[55 跳跃游戏](https://leetcode-cn.com/problems/jump-game/)[Li]

这道题很简单，关键是要借鉴动态规划的方法，每一步只要可以求出到此位置的剩余最大跳跃次数就可以。
```python
class Solution:
    def canJump(self, nums):
        dp = 1
        for i in range(len(nums)-1):
            dp = max(nums[i],dp-1)
            if dp==0: return False
        return True
```
当然，这题也有一个让人十分容易绕进去的点，观察下面的错误写法和上面的写法有什么不同：
```python
class Solution:
    def canJump(self, nums):
        dp=1
        for i in nums:
            dp=max(dp-1,i)
            if dp==0:
                return False
        return True
```
唯一的区别在于for循环。事实上我们观察测试用例[1,0,1,0]，其实第一个0和第二个0是有显著区别的，在第一个0位置我们必须要保证大于1，而在最后一个0我们只需要到达即可，所以最后一个数其实是不能被考虑进来的。


[198 打家劫舍](https://leetcode-cn.com/problems/house-robber/)[Ye]
```python
def rob(nums):
    if len(nums)==0:return 0
    if len(nums)==1:return nums[0]
    dp=[0 for i in range(len(nums)+1)]
    dp[1]=nums[0]
    for i in range(2,len(nums)+1):
        dp[i]=max(dp[i-1],dp[i-2]+nums[i-1])
    return dp[-1]
a=[2,7,9,3,1]
print(rob(a))
```
[215. 数组中的第K个最大元素](https://leetcode-cn.com/problems/kth-largest-element-in-an-array/)
```python
class Solution:
    def findKthLargest(self, nums: List[int], k: int) -> int:
        def HeapAdjust(nums,k,n):
            while(2*k+1<n):
                j=2*k+1
                if j+1<n and nums[j]<nums[j+1]:
                    j=j+1
                if nums[j]>nums[k]:
                    temp=nums[k]
                    nums[k]=nums[j]
                    nums[j]=temp
                    k=j
                else:
                    break
            return nums
        n=len(nums)
        for i in range(int(n/2)-1,-1,-1):
            nums=HeapAdjust(nums,i,n)
        for i in range(n-1,n-k,-1):
            nums[0],nums[i]=nums[i],nums[0]
            nums=HeapAdjust(nums,0,i)
        return nums[0]

```
[347. 前 K 个高频元素](https://leetcode-cn.com/problems/top-k-frequent-elements/)[Liu]
这两题参考./sorted
```python
class Solution:
    def topKFrequent(self, nums: List[int], k: int) -> List[int]:
        counter = collections.Counter(nums)
        val = list(counter.keys())
        l, r = 0, len(val) - 1
        while l <= r:
            pivot = self.partition(val, l, r, counter)
            if pivot == k - 1:
                return val[:k]
            if pivot > k - 1:
                r = pivot - 1
            else:
                l = pivot + 1

    def partition(self, val, l, r, counter):
        pivot = r
        right = l
        for i in range(l, r):
            if counter.get(val[i]) >= counter.get(val[pivot]):
                val[i], val[right] = val[right], val[i]
                right += 1
        val[right], val[pivot] = val[pivot], val[right]
        return right
```

## 2021.1.26
[102. 二叉树的层序遍历](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)[Liu]
```python
import Tree
class Solution:
    def levelOrder(self, root) :
        if not root:return []
        quene=[]
        quene.append(root)
        res=[]
        while len(quene)>0:
            temp=[]
            for i in range(len(quene)):
                node=quene.pop(0)
                temp.append(node.val)
                if node.left:
                    quene.append(node.left)
                if node.right:
                    quene.append(node.right)
            res.append(temp[:])
        return res
tt=Tree.TreeNodeTools()
root3=tt.createTreeByrow([5,4,8,11,'null',13,4,7,2,'null','null',5,1],0)
ss=Solution()
print(ss.levelOrder(root3))
```

[206. 反转链表](https://leetcode-cn.com/problems/reverse-linked-list/)[Li]
```python
#迭代
class Solution:
    def reverseList(self, head: ListNode) -> ListNode:
        if not head:
            return None
        pre,cur = head,head.next
        pre.next = None
        while cur:
            temp = cur.next
            cur.next= pre
            pre,cur = cur,temp
        return pre
#递归
import List
def reverse(llist):
    if not llist or not llist.next:return llist
    end=reverse(llist.next)
    llist.next.next=llist
    llist.next=None
    return end
ll=List.ListNodeTools()
llist=ll.create([1,2,3,4,5])
# ll.printf(llist)
print(ll.printf(reverse(llist)))
```

[287. 寻找重复数](https://leetcode-cn.com/problems/find-the-duplicate-number/)[Ye]
```python

class Solution:
    def findDuplicate(self, nums: List[int]) -> int:
        size = len(nums)
        left = 1
        right = size - 1
        while left < right:
            mid = left + (right - left) // 2
            cnt = 0
            for num in nums:
                if num <= mid:
                    cnt += 1
            # 根据抽屉原理，小于等于 4 的数的个数如果严格大于 4 个，
            # 此时重复元素一定出现在 [1, 4] 区间里
            if cnt > mid:
                # 重复的元素一定出现在 [left, mid] 区间里
                right = mid
            else:
                # if 分析正确了以后，else 搜索的区间就是 if 的反面
                # [mid + 1, right]
                left = mid + 1
        return left
```

### 2021.1.28 第二周
[104. 二叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)
[543. 二叉树的直径](https://leetcode-cn.com/problems/diameter-of-binary-tree/)[Liu]

先看一下树高怎么求：
```python
import Tree
def deeptree(root):
    if not root:return 0
    left=deeptree(root.left)
    right=deeptree(root.right)
    return max(left,right)+1
```
然后改成求最大直径：
```python
import Tree
class Solution:
    def diameterOfBinaryTree(self, root) -> int:
        self.ans = 1
        def depth(root):
            if not root: return 0
            L = depth(root.left)
            R = depth(root.right)
            self.ans = max(self.ans, L + R + 1)
            return max(L, R) + 1
        depth(root)
        return self.ans - 1
ss=Solution()
ss1=Tree.TreeNodeTools()
root=ss1.createTreeByrow([5,4,8,11,'null',13,4,7,2,'null','null',5,1],0)
print(ss.diameterOfBinaryTree(root))
```

[148. 排序链表](https://leetcode-cn.com/problems/sort-list/)[Li]
```python
#链表快排（超时）
class Solution:
    def sortList(self, head: ListNode) -> ListNode:
        if not head:
            return None
        right = head
        while right.next:
            right=right.next
        def partition(head,left,right):
            povit=right.val
            temp=pre =cur=left
            while cur!=right:
                if povit>cur.val:
                    pre.val,cur.val = cur.val,pre.val
                    temp = pre
                    pre = pre.next
                cur = cur.next
            pre.val,right.val=right.val,pre.val
            return temp,pre    

        def quicksort(head,left,right):
            if left!=right:
                temp,pre=partition(head,left,right)
                if pre!=right:
                    quicksort(head,pre.next,right)
                quicksort(head,left,temp)
            return head
        return quicksort(head,head,right)

#归并排序 自上而下
class Solution:
    def sortList(self, head: ListNode) -> ListNode:
        if not head or not head.next: 
            return head
        slow = head
        fast = head
        # 用快慢指针分成两部分
        while fast.next and fast.next.next:
            slow = slow.next
            fast = fast.next.next
        # 找到左右部分, 把左部分最后置空
        mid = slow.next
        slow.next = None
        # 递归下去
        left = self.sortList(head)
        right = self.sortList(mid)
        # 合并
        return self.merge(left, right)

    def merge(self, left, right):
        dummy = ListNode(0)
        p = dummy
        l = left
        r = right

        while l and r:
            if l.val < r.val:
                p.next = l
                l = l.next
                p = p.next
            else:
                p.next = r
                r = r.next
                p = p.next
        if l:
            p.next = l
        if r:
            p.next = r
        return dummy.next
```
[337打家劫舍III](https://leetcode-cn.com/problems/house-robber-iii/)[Ye]
```python
class Solution:
    def rob(self, root: TreeNode) -> int:
        def _rob(root):
            if not root: return 0, 0  # 偷，不偷
            left = _rob(root.left)
            right = _rob(root.right)
        # 偷当前节点, 则左右子树都不能偷
            v1 = root.val + left[1] + right[1]
        # 不偷当前节点, 则取左右子树中最大的值
            v2 = max(left) + max(right)
            return v1, v2
        return max(_rob(root))
```
### 2021.1.30
[1. 两数之和](https://leetcode-cn.com/problems/two-sum/)

[15. 三数之和](https://leetcode-cn.com/problems/3sum/)[Liu]
首先求出两数之和：

```python
def twosum(nums,target):
    nums.sort()
    left=0
    right=len(nums)-1
    while left<=right:
        if nums[left]+nums[right]>target:
            right-=1
        elif nums[left]+nums[right]<target:
            left+=1
        else:
            return [left,right]
    return False
nums=[3,2,4]
print(twosum(nums,6))
```
由于本题要求我们求出的是索引值，所以我们来修改一下：
```python
def twosum(nums,target):
    # nums.sort()
    number=[]
    for i in range(len(nums)):
        number.append((nums[i],i)) 
    number.sort()
    left=0
    right=len(nums)-1
    while left<=right:
        if number[left][0]+number[right][0]>target:
            right-=1
        elif number[left][0]+number[right][0]<target:
            left+=1
        else:
            return [number[left][1],number[right][1]]
    return False
nums=[3,3]
print(twosum(nums,6))
```

在两数的基础上再求三数之和：
```python
def twosum(nums,target):
    left=0
    right=len(nums)-1
    res=[]
    while left<right:
        if nums[left]+nums[right]>target:
            right-=1
        elif nums[left]+nums[right]<target:
            left+=1
        else:
            res.append([nums[left],nums[right]])
            left+=1
            right-=1
    return res

def treesum(nums):
    nums.sort()
    res=[]
    for i in range(len(nums)):
        tt=twosum(nums[i+1:],-nums[i])
        for t in tt:
            tem=[nums[i]]+t
            if tem not in res:
                res.append(tem)
    return res

nums=[-2,0,1,1,2]
print(treesum(nums))
```
3sum解决了,那么nsum怎么解答，比如n==100？

最后来讲讲二分查找的三种写法：
```python
#二分查找经典写法
def binaysearch(nums,target):
        left=0
        right=len(nums)-1
        while left<=right: 
                mid=left+(right-left)//2 
                if nums[mid]<target:
                        left=mid+1
                elif nums[mid]>target:
                        right=mid-1
                elif nums[mid]==target:
                         return mid
        return -1
num=[1,2,3,9,10,45]
print(binaySearch(num,45))

#下面做边界和右边界问题
def rightbinaysearch(nums,target):
        left=0
        right=len(nums)-1
        while left<=right:
                mid=left+(right-left)//2
                if nums[mid]<target:
                        left=mid+1
                elif nums[mid]>target:
                        right=mid-1
                elif nums[mid]==target:
                        left=mid+1
        # if left>=len(nums) or nums[left]!=target:
        #         return -1
        if right<0 or nums[right]!=target:
                return -1
        return right

def leftbinaysearch(nums,target):
        left=0
        right=len(nums)-1
        while left<=right:
                mid=left+(right-left)//2
                if nums[mid]<target:
                        left=mid+1
                elif nums[mid]>target:
                        right=mid-1
                elif nums[mid]==target:
                        right=mid-1
        if left>=len(nums) or nums[left]!=target:
                return -1
        return left

```

[221.最大正方形](https://leetcode-cn.com/problems/maximal-square/)[Ye]
```python
def maximalSquare(matrix) -> int:
    dp = [[0 for i in range(len(matrix[0]))] for i in range(len(matrix))]
    #首先把第一行和第一列都赋值到dp数组里面,这道题要注意输入的都是char要转换成int
    for i in range(len(dp)):
        dp[i][0] = int(matrix[i][0])
    for i in range(len(dp[0])):
        dp[0][i] = int(matrix[0][i])
    #如果周围三个都是1，那么就加1
    for i in range(1, len(dp)):
        for j in range(1, len(dp[0])):
            dp[i][j] = int((matrix[i][j]))
            if (matrix[i][j] == '1' and matrix[i][j - 1] == '1' and matrix[i - 1][j] == '1' and matrix[i - 1][j - 1] == '1'):
                dp[i][j] = min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]) + 1
    #按照列取最大值后平方
    return max(map(max, dp))**2
print(maximalSquare([["1","0","1","0","0"],["1","0","1","1","1"],["1","1","1","1","1"],["1","0","0","1","0"]]))
```

[9.删除链表的倒数第 N 个结点](https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/)[Li]
```python
#19.删除链表的倒数第 N 个结点
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def removeNthFromEnd(self, head: ListNode, n: int) -> ListNode:
        node = ListNode(0)
        node.next = head 
        
        #step1: 快指针先走n步
        slow, fast = node, node
        for _ in range(n):
            fast = fast.next 

        #step2: 快慢指针同时走，直到fast指针到达尾部节点，此时slow到达倒数第N个节点的前一个节点
        while fast and fast.next:
            slow, fast = slow.next, fast.next 
        
        #step3: 删除节点，并重新连接
        slow.next = slow.next.next 
        return node.next 
```

### 2021.2.2
[236. 二叉树的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/)[Liu]

```python
def lowestCommonAncestor(root,p,q):
    if root==None:return None
    if root==p or root==q:
        return root
    left=lowestCommonAncestor(root.left,p,q)
    right=lowestCommonAncestor(root.right,p,q)
    #两个都有，根据后续遍历的特点root就是两个的前一个节点
    if left!=None and right!=None:
        return root
    #两个都不存在返回none
    if left==None and right==None:
        return None
    #一个存在一个不存在说明存在的那个是公共祖先
    return right if left==None else left

import Tree
ss=Tree.TreeNodeTools()
root=ss.createTreeByrow([3,5,1,6,2,0,8,'null','null',7,4],0)
t5=root.left
t4=root.left.right.right
t1=root.right
print(lowestCommonAncestor(root,t5,t4).val)
```

[5. 最长回文子串](https://leetcode-cn.com/problems/longest-palindromic-substring/)[Li]

```python
class Solution:
    def longestPalindrome(self, s: str) -> str:
        n = len(s)
        dp = [[False] * n for _ in range(n)]
        ans = ""
        for j in range(n):
            for i in range(j+1):
                #这个相当于自己肯定是回文
                if i==j:
                    dp[i][j]=True
                #这个相当于2个的情况，回文与否取决于两个是否相等
                elif i==j-1:
                    dp[i][j]=(s[i]==s[j])
                #这个相当于两头相等的情况下，中间是回文就是回文
                else:
                    dp[i][j]=(s[i]==s[j] and dp[i+1][j-1])
                #当前是后文，而且大于ans就记录下来
                if dp[i][j] and j-i+1>len(ans):
                    ans=s[i:j+1]
        return ans
```

[11. 盛最多水的容器](https://leetcode-cn.com/problems/container-with-most-water/)[Ye]
```python
def compute(height):
    left=0
    right=len(height)-1
    res=0
    while left<right:
        if height[left]<height[right]:
            res=max(res,(right-left)*height[left])
            left+=1
        else:
            res=max(res,(right-left)*height[right])
            right-=1
    return res
print(compute([1,8,6,2,5,4,8,3,7]))
```

### 2021.2.4 第三周
[146. LRU 缓存机制](https://leetcode-cn.com/problems/lru-cache/)[Li]
```python
class DLinkedNode:
    def __init__(self, key=0, value=0):
        self.key = key
        self.value = value
        self.prev = None
        self.next = None
class LRUCache:
    def __init__(self, capacity: int):
        self.cache = dict()
        # 使用伪头部和伪尾部节点    
        self.head = DLinkedNode()
        self.tail = DLinkedNode()
        self.head.next = self.tail
        self.tail.prev = self.head
        self.capacity = capacity
        self.size = 0
    def get(self, key: int) -> int:
        if key not in self.cache:
            return -1
        # 如果 key 存在，先通过哈希表定位，再移到头部
        node = self.cache[key]
        self.moveToHead(node)
        return node.value

    def put(self, key: int, value: int) -> None:
        if key not in self.cache:
            # 如果 key 不存在，创建一个新的节点
            node = DLinkedNode(key, value)
            # 添加进哈希表
            self.cache[key] = node
            # 添加至双向链表的头部
            self.addToHead(node)
            self.size += 1
            if self.size > self.capacity:
                # 如果超出容量，删除双向链表的尾部节点
                removed = self.removeTail()
                # 删除哈希表中对应的项
                self.cache.pop(removed.key)
                self.size -= 1
        else:
            # 如果 key 存在，先通过哈希表定位，再修改 value，并移到头部
            node = self.cache[key]
            node.value = value
            self.moveToHead(node)
    def addToHead(self, node):
        node.prev = self.head
        node.next = self.head.next
        self.head.next.prev = node
        self.head.next = node
    
    def removeNode(self, node):
        node.prev.next = node.next
        node.next.prev = node.prev

    def moveToHead(self, node):
        self.removeNode(node)
        self.addToHead(node)

    def removeTail(self):
        node = self.tail.prev
        self.removeNode(node)
        return node
    def printf(self):
        for k,v in self.cache.items():
            print(k,v.value)
ss=LRUCache(3)
ss.put(1,2)
ss.put(2,3)
ss.put(3,4)
ss.put(4,5)
# ss.printf()
print(ss.get(3))
ss.put(6,7)
ss.put(7,8)
ss.printf()

```

[739. 每日温度](https://leetcode-cn.com/problems/daily-temperatures/)[Li]
```python
class Solution:
    def dailyTemperatures(self, T) :
        res = [0 for _ in T]
        stack = []
        for i in range(len(T)):
            while stack and T[i]>T[stack[-1]]:
                topIndex = stack.pop()
                res[topIndex]=i-topIndex
            stack.append(i)
        return res
```

[240. 搜索二维矩阵 II](https://leetcode-cn.com/problems/search-a-2d-matrix-ii/)[Ye]
```python
#240搜索二维矩阵 方法二
def searchMatrix(matrix, target):
    if not matrix:
        return False
    def search_rec(left, up, right, down):
        if left > right or up > down:
            return False
        # 如果target比矩阵最小值还小，或比最大值还大
        elif target < matrix[up][left] or target > matrix[down][right]:
            return False
        mid = left + (right - left) // 2

        row = up
        while row <= down and matrix[row][mid] <= target:
            if matrix[row][mid] == target:
                return True
            row += 1
        return search_rec(left, row, mid - 1, down) or search_rec(mid + 1, up, right, row - 1)
    return search_rec(0, 0, len(matrix[0]) - 1, len(matrix) - 1)

#240搜索二维矩阵 方法三
class Solution:
    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:
        left=len(matrix[0])-1
        up=0
        while(up<len(matrix) and left>=0):
            if matrix[up][left]==target:
                return True
            if matrix[up][left]>target:
                left-=1
            else:
                up+=1
        return False
```
叶题解：
![搜索二维矩阵](./pic/240/240.png)

### 2021.2.5
[114. 二叉树展开为链表](https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/)
拿到这道题，马上想到二叉树的DFS遍历，两种：递归的和非递归的。非递归的很简单不表。
递归也有两种方法，第一种我们可以设立list来记录，然后将list转成链表，可是多了个循环太不优雅了。
第二种在递归中将链表拼接起来，这个方法要脑子非常清楚递归的顺序,同时也要明白在向上递归的时候root会被覆。，所以要设立一个全局指针，这个和设立list来记录值是不同的，List的话天然就是一个全局的变量。
```python
from Tree import TreeNode,TreeNodeTools
class Solution:
    def flatten(self, root: TreeNode) -> None:
        """
        Do not return anything, modify root in-place instead.
        """
        temp=TreeNode()
        res=temp
        def dfs(root):
            if root==None:return None
            nonlocal temp
            temp.right=TreeNode(root.val)
            temp=temp.right
            dfs(root.left)
            dfs(root.right)
        dfs(root)
        root.left=None
        root.right=res.right.right
ss=Solution()
root=TreeNodeTools().createTreeByrow([1,2,5,3,4,'null',6],0)
ss.flatten(root)
TreeNodeTools().printfH(root)
```

