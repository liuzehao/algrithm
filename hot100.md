# Hot100
## 2021.1.22 第一周
## [48. 旋转图像](https://leetcode-cn.com/problems/rotate-image/solution/li-kou-48xiao-bai-du-neng-kan-dong-de-fang-fa-zhu-/)[Liu]
这题是一道矩阵旋转类型的题目，本质上是两数交换的高级版.并且矩阵问题有很深的应用，是很好的题。
下图以最外围为例，不同颜色的区块代表了需要置换的区域：

![show1](./pic/48/show1.png)

我们来寻找其中的规律，以四个角为例子，我们发现可以采用两个变量来表示四个角。顺时针方向分别是(pos1,pos1),(pos1,pos2),(pos2,po2),(pos2,pos1)。我们只要交换这四个角就可以完成这四个数的交换，之后我们需要一次遍历傍边的数，我们引入一个add来完成这个操作。由于pos1+add< pos2，我们找到了循环结束条件。

![show2](./pic/48/show2.png)

外圈循环结束之后，我们进入里圈。我们将pos1+1,pos2-1自然就进入了里圈。循环结束条件是pos1< pos2。
```python
def rotate(matrix):
    pos1,pos2=0,len(matrix)-1
    while pos1<pos2:
        add=0
        while add<pos2-pos1:
            temp=matrix[pos1+add][pos2]
            matrix[pos1+add][pos2]=matrix[pos1][pos1+add]
            matrix[pos1][pos1+add]=matrix[pos2-add][pos1]
            matrix[pos2-add][pos1]=matrix[pos2][pos2-add]
            matrix[pos2][pos2-add]=temp
            add+=1
        pos1+=1
        pos2-=1
# matrix=[[1,2,3],[4,5,6],[7,8,9]] demo1
matrix=[[ 5, 1, 9,11],[ 2, 4, 8,10],[13, 3, 6, 7],[15,14,12,16]]#demo2
print(rotate(matrix))
```

当然由于python的特性，我们也可以不要temp:
```python
def rotate(matrix):
    pos1=0
    pos2=len(matrix)-1
    while pos1<pos2:
        add=0
        while pos1+add<pos2:
            matrix[pos1+add][pos2],matrix[pos2][pos2-add],matrix[pos2-add][pos1],matrix[pos1][pos1+add]=matrix[pos1][pos1+add],matrix[pos1+add][pos2],matrix[pos2][pos2-add],matrix[pos2-add][pos1]
            add+=1
        pos1+=1
        pos2-=1
matrix=[[ 5, 1, 9,11],[ 2, 4, 8,10],[13, 3, 6, 7],[15,14,12,16]]
print(rotate(matrix))
```
但不建议这么写，一是可读性太差了，二是不利于调试。

## [75. 颜色分类](https://leetcode-cn.com/problems/sort-colors/)[Li]

```python
#75. 颜色分类
class Solution:
    def sortColors(self, nums)-> None:
        """
        原地修改
        """
        p0=cur=0;p2=len(nums)
        while cur<p2:
            if nums[cur]==0:
                nums[cur],nums[p0]=nums[p0],nums[cur]
                #p0、cur同时右移
                cur+=1
                p0+=1
            elif nums[cur]==1:
                #1时不交换，cur右移
                cur+=1
            else:
                nums[cur],nums[p2]=nums[p2],nums[cur]
                p2-=1
```
## 2021.1.23
[55 跳跃游戏](https://leetcode-cn.com/problems/jump-game/)[Li]
```python
class Solution:
    def canJump(self, nums):
        dp = 1
        for i in range(len(nums)-1):
            dp = max(nums[i],dp-1)
            if dp==0: return False
        return True
```
[198 打家劫舍](https://leetcode-cn.com/problems/house-robber/)[Ye]
```python
class Solution:
    def rob(self, nums: List[int]) -> int:
        if len(nums)==0:return 0
        if len(nums)==1:return nums[0]
        dp=[0 for i in range(len(nums)+1)]
        dp[0]=0
        dp[1]=nums[0]
        for i in range(2,len(nums)+1):
            dp[i]=max(dp[i-1],dp[i-2]+nums[i-1])
        return dp[-1]
```
[215. 数组中的第K个最大元素](https://leetcode-cn.com/problems/kth-largest-element-in-an-array/)
```python
class Solution:
    def findKthLargest(self, nums: List[int], k: int) -> int:
        def HeapAdjust(nums,k,n):
            while(2*k+1<n):
                j=2*k+1
                if j+1<n and nums[j]<nums[j+1]:
                    j=j+1
                if nums[j]>nums[k]:
                    temp=nums[k]
                    nums[k]=nums[j]
                    nums[j]=temp
                    k=j
                else:
                    break
            return nums
        n=len(nums)
        for i in range(int(n/2)-1,-1,-1):
            nums=HeapAdjust(nums,i,n)
        for i in range(n-1,n-k,-1):
            nums[0],nums[i]=nums[i],nums[0]
            nums=HeapAdjust(nums,0,i)
        return nums[0]

```
[347. 前 K 个高频元素](https://leetcode-cn.com/problems/top-k-frequent-elements/)[Liu]
这两题参考./sorted
```python
class Solution:
    def topKFrequent(self, nums: List[int], k: int) -> List[int]:
        counter = collections.Counter(nums)
        val = list(counter.keys())
        l, r = 0, len(val) - 1
        while l <= r:
            pivot = self.partition(val, l, r, counter)
            if pivot == k - 1:
                return val[:k]
            if pivot > k - 1:
                r = pivot - 1
            else:
                l = pivot + 1

    def partition(self, val, l, r, counter):
        pivot = r
        right = l
        for i in range(l, r):
            if counter.get(val[i]) >= counter.get(val[pivot]):
                val[i], val[right] = val[right], val[i]
                right += 1
        val[right], val[pivot] = val[pivot], val[right]
        return right
```

## 2021.1.26
[102. 二叉树的层序遍历](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)[Liu]
```python
import Tree
class Solution:
    def levelOrder(self, root) :
        if not root:return []
        quene=[]
        quene.append(root)
        res=[]
        while len(quene)>0:
            temp=[]
            for i in range(len(quene)):
                node=quene.pop(0)
                temp.append(node.val)
                if node.left:
                    quene.append(node.left)
                if node.right:
                    quene.append(node.right)
            res.append(temp[:])
        return res
tt=Tree.TreeNodeTools()
root3=tt.createTreeByrow([5,4,8,11,'null',13,4,7,2,'null','null',5,1],0)
ss=Solution()
print(ss.levelOrder(root3))
```

[206. 反转链表](https://leetcode-cn.com/problems/reverse-linked-list/)[Li]
```python
#迭代
class Solution:
    def reverseList(self, head: ListNode) -> ListNode:
        if not head:
            return None
        pre,cur = head,head.next
        pre.next = None
        while cur:
            temp = cur.next
            cur.next= pre
            pre,cur = cur,temp
        return pre
#递归
import List
def reverse(llist):
    if not llist or not llist.next:return llist
    end=reverse(llist.next)
    llist.next.next=llist
    llist.next=None
    return end
ll=List.ListNodeTools()
llist=ll.create([1,2,3,4,5])
# ll.printf(llist)
print(ll.printf(reverse(llist)))
```

[287. 寻找重复数](https://leetcode-cn.com/problems/find-the-duplicate-number/)[Ye]
```python

class Solution:
    def findDuplicate(self, nums: List[int]) -> int:
        size = len(nums)
        left = 1
        right = size - 1
        while left < right:
            mid = left + (right - left) // 2
            cnt = 0
            for num in nums:
                if num <= mid:
                    cnt += 1
            # 根据抽屉原理，小于等于 4 的数的个数如果严格大于 4 个，
            # 此时重复元素一定出现在 [1, 4] 区间里
            if cnt > mid:
                # 重复的元素一定出现在 [left, mid] 区间里
                right = mid
            else:
                # if 分析正确了以后，else 搜索的区间就是 if 的反面
                # [mid + 1, right]
                left = mid + 1
        return left
```

### 2021.1.28 第二周
[104. 二叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)
[543. 二叉树的直径](https://leetcode-cn.com/problems/diameter-of-binary-tree/)[Liu]

先看一下树高怎么求：
```python
import Tree
def deeptree(root):
    if not root:return 0
    left=deeptree(root.left)
    right=deeptree(root.right)
    return max(left,right)+1
```
然后改成求最大直径：
```python
import Tree
class Solution:
    def diameterOfBinaryTree(self, root) -> int:
        self.ans = 1
        def depth(root):
            if not root: return 0
            L = depth(root.left)
            R = depth(root.right)
            self.ans = max(self.ans, L + R + 1)
            return max(L, R) + 1
        depth(root)
        return self.ans - 1
ss=Solution()
ss1=Tree.TreeNodeTools()
root=ss1.createTreeByrow([5,4,8,11,'null',13,4,7,2,'null','null',5,1],0)
print(ss.diameterOfBinaryTree(root))
```

[148. 排序链表](https://leetcode-cn.com/problems/sort-list/)[Li]
```python
#链表快排（超时）
class Solution:
    def sortList(self, head: ListNode) -> ListNode:
        if not head:
            return None
        right = head
        while right.next:
            right=right.next
        def partition(head,left,right):
            povit=right.val
            temp=pre =cur=left
            while cur!=right:
                if povit>cur.val:
                    pre.val,cur.val = cur.val,pre.val
                    temp = pre
                    pre = pre.next
                cur = cur.next
            pre.val,right.val=right.val,pre.val
            return temp,pre    

        def quicksort(head,left,right):
            if left!=right:
                temp,pre=partition(head,left,right)
                if pre!=right:
                    quicksort(head,pre.next,right)
                quicksort(head,left,temp)
            return head
        return quicksort(head,head,right)

#归并排序 自上而下
class Solution:
    def sortList(self, head: ListNode) -> ListNode:
        if not head or not head.next: return head #终止
        # 快慢指针切割
        slow, fast = head, head.next
        while fast and fast.next: #fast?
            fast, slow = fast.next.next, slow.next
        mid, slow.next = slow.next, None  
        # 递归切割
        left, right = self.sortList(head), self.sortList(mid)
        #  `left` and `right`子链归并
        #创建头结点
        cur = h = ListNode(0)
        while left and right:
            if left.val < right.val: cur.next, left = left, left.next
            else: cur.next, right = right, right.next
            cur = cur.next
        cur.next = left if left else right
        return h.next
```
[337打家劫舍III](https://leetcode-cn.com/problems/house-robber-iii/)
```python
class Solution:
    def rob(self, root: TreeNode) -> int:
        def _rob(root):
            if not root: return 0, 0  # 偷，不偷

            left = _rob(root.left)
            right = _rob(root.right)
        # 偷当前节点, 则左右子树都不能偷
            v1 = root.val + left[1] + right[1]
        # 不偷当前节点, 则取左右子树中最大的值
            v2 = max(left) + max(right)
            return v1, v2
        return max(_rob(root))
```
### 2021.1.30
[1. 两数之和](https://leetcode-cn.com/problems/two-sum/)
[15. 三数之和](https://leetcode-cn.com/problems/3sum/)[Liu]
首先求出两数之和：
```python
def twosum(nums,target):
    nums.sort()
    left=0
    right=len(nums)-1
    while left<=right:
        if nums[left]+nums[right]>target:
            right-=1
        elif nums[left]+nums[right]<target:
            left+=1
        else:
            return [left,right]
    return False
nums=[3,2,4]
print(twosum(nums,6))
```
由于本题要求我们求出的是索引值，所以我们来修改一下：
```python
def twosum(nums,target):
    # nums.sort()
    number=[]
    for i in range(len(nums)):
        number.append((nums[i],i))
    number.sort()
    left=0
    right=len(nums)-1
    while left<=right:
        if number[left][0]+number[right][0]>target:
            right-=1
        elif number[left][0]+number[right][0]<target:
            left+=1
        else:
            return [number[left][1],number[right][1]]
    return False
nums=[3,3]
print(twosum(nums,6))
```

在两数的基础上再求三数之和：
```python
def twosum(nums,target):
    left=0
    right=len(nums)-1
    res=[]
    while left<right:
        if nums[left]+nums[right]>target:
            right-=1
        elif nums[left]+nums[right]<target:
            left+=1
        else:
            res.append([nums[left],nums[right]])
            left+=1
            right-=1
    return res
def treesum(nums):
    nums.sort()
    res=[]
    for i in range(len(nums)):
        tt=twosum(nums[i+1:],-nums[i])
        for t in tt:
            tem=[nums[i]]+t
            if tem not in res:
                res.append(tem)
    return res

nums=[-2,0,1,1,2]
print(treesum(nums))
```
3sum解决了,那么nsum怎么解答，比如n==100？

最后来讲讲二分查找的三种写法：
```python
#二分查找经典写法
def binaysearch(nums,target):
        left=0
        right=len(nums)-1
        while left<=right: 
                mid=left+(right-left)//2
                if nums[mid]<target:
                        left=mid+1
                elif nums[mid]>target:
                        right=mid-1
                elif nums[mid]==target:
                         return mid
        return -1
num=[1,2,3,9,10,45]
print(binaySearch(num,45))

#下面做边界和右边界问题
def rightbinaysearch(nums,target):
        left=0
        right=len(nums)-1
        while left<=right:
                mid=left+(right-left)//2
                if nums[mid]<target:
                        left=mid+1
                elif nums[mid]>target:
                        right=mid-1
                elif nums[mid]==target:
                        left=mid+1
        # if left>=len(nums) or nums[left]!=target:
        #         return -1
        if right<0 or nums[right]!=target:
                return -1
        return right

def leftbinaysearch(nums,target):
        left=0
        right=len(nums)-1
        while left<=right:
                mid=left+(right-left)//2
                if nums[mid]<target:
                        left=mid+1
                elif nums[mid]>target:
                        right=mid-1
                elif nums[mid]==target:
                        right=mid-1
        if left>=len(nums) or nums[left]!=target:
                return -1
        return left

```

[221.最大正方形](https://leetcode-cn.com/problems/maximal-square/)[Ye]

[9.删除链表的倒数第 N 个结点](https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/)[Li]
